version "3.3.0"

#include "ZScript/W2Data.zsc"
#include "ZScript/W2PlayerHandler.zsc"
#include "ZScript/W2AmbientActors.zsc"

const mcm_WeathremumVersion = "0.18";


class mcm_WeathremumHandler: EventHandler {
	bool mustCreateGeneralSectorsData;		// "PlayerEntered()" is called before "WorldLoaded()".

	W2LevelGeneralData w2level;
	W2PlayerHandler playerHandlers[ MAXPLAYERS ];

	Array<int> groupNumsSubstitution;		// Quick access provided for the pre-handling process of megasectors.
	int nextGroupNum;						// Also for uniting all neighbour sectors. Main work variable.

	override void OnRegister() {
		SetOrder( WeathremumHandlerOrder );

		mustCreateGeneralSectorsData = true;
		w2level = new( 'W2LevelGeneralData' );

		Super.OnRegister();
	}


	private void adjustSectorGroupNum( W2SectorData closeSectorData ) {
		// Uniting all adjacent sectors with same type to one group (in O(1), really!).

		if ( closeSectorData.groupnum == -1 ) {
			closeSectorData.groupnum = nextGroupNum;

		} else if ( closeSectorData.groupnum != groupNumsSubstitution[ nextGroupNum ] ) {
			int groupNumToGet = groupNumsSubstitution[ min( closeSectorData.groupnum, groupNumsSubstitution[ nextGroupNum ] ) ];
			int groupToSet = max( closeSectorData.groupnum, groupNumsSubstitution[ nextGroupNum ] );

			groupNumsSubstitution[ groupNumsSubstitution[ groupToSet ] ] = groupNumToGet;
			groupNumsSubstitution[ groupToSet ] = groupNumToGet;
		}
	}

	private void setNextToOutdoorSectorData( Line curline, Sector ls ) {
		W2SectorData closeSectorData = w2level.allSectorsData[ ls.Index() ];

		if ( ls.GetTexture( Sector.ceiling ) != skyflatnum ) {
			closeSectorData.w2type = W2ST_NextToOutdoor;
			w2level.corniceLinesFlags[ curline.Index() ] = 1;
		} else {
			adjustSectorGroupNum( closeSectorData );
		}
	}

	private void setNextToSillSectorData( Sector lsector ) {
		W2SectorData closeSectorData = w2level.allSectorsData[ lsector.Index() ];

		if ( closeSectorData.w2type == W2ST_NextToOutdoor )
			adjustSectorGroupNum( closeSectorData );
	}

	void CreateGeneralSectorsData( void ) {
		nextGroupNum = 0;
		groupNumsSubstitution.Clear();

		w2level.allSectorsData.Clear();
		w2level.allSectorGroups.Clear();
		w2level.realSectorGroups.Clear();
		w2level.corniceLinesFlags.Clear();

		// Save all of the level lines and sectors for the quick index-based
		//access. Filled up before any other operations because the next ones
		//may (and will) get any element, not only less than their "Index()".
		for ( int i = 0; i < level.lines.Size(); i++ )
			w2level.corniceLinesFlags.Push( 0 );

		for ( int i = 0; i < level.sectors.Size(); i++ )
			w2level.allSectorsData.Push( W2SectorData.Create( level.Sectors[ i ] ) );

		// Understand its data such as "w2type" and "groupnum" for sectors under sky:
		for ( int i = 0; i < level.sectors.Size(); i++ ) {
			//console.printf( "Sector " .. i .. ": " .. level.Sectors[ i ].GetTexture( Sector.ceiling ) .. "." );
			Sector s = level.Sectors[ i ];

			if ( s.GetTexture( Sector.ceiling ) == skyflatnum ) {
				W2SectorData curOutdoorSectorData = w2level.allSectorsData[ i ];

				// Setting relationship to neighbour sectors:
				curOutdoorSectorData.w2type = W2ST_Outdoor;
				curOutdoorSectorData.groupnum = nextGroupNum;
				groupNumsSubstitution.Push( nextGroupNum );

				for ( int j = 0; j < s.Lines.Size(); j++ ) {
					Line l = s.Lines[ j ];
					Sector lsector = l.frontsector;

					if ( lsector && lsector != s )
						setNextToOutdoorSectorData( l, lsector );

					lsector = l.backsector;

					if ( lsector && lsector != s )
						setNextToOutdoorSectorData( l, lsector );
				}

				// Understanding the sector floor terrain Weathremum type:
				String floorTexName = TexMan.GetName( s.GetTexture( s.FLOOR ) );
				String floorTexNameLeft5 = floorTexName.Left( 5 );
				String floorTexNameLeft6 = floorTexName.Left( 6 );

				bool isSlime00Slime08 = ( floorTexNameLeft6 == "SLIME0" && floorTexName.CharCodeAt( 6 ) <= 0x38 );

				if ( floorTexNameLeft6 == "FWATER" || ( isSlime00Slime08 && s.damageamount ) ) {
					curOutdoorSectorData.w2floor = W2FT_Water;

				} else if ( floorTexNameLeft5 == "SLIME" || floorTexNameLeft5 == "RROCK" ) {
					int texSubindex = floorTexName.Mid( 5, 2 ).ToInt();

					if (     isSlime00Slime08
						|| ( floorTexNameLeft5 == "SLIME" && texSubindex >= 9 && texSubindex <= 12 )
						|| ( floorTexNameLeft5 == "RROCK" && texSubindex <= 8 && texSubindex != 3 && texSubindex != 4 ) ) {
						curOutdoorSectorData.w2floor = W2FT_Incandecent;

					} else if ( floorTexNameLeft5 == "RROCK" ) {
						curOutdoorSectorData.w2floor = W2FT_HardSurface;
					}

				} else if ( floorTexNameLeft5 == "METAL" ) {
					curOutdoorSectorData.w2floor = W2FT_HardSurface;

				} else if ( floorTexName.Left( 4 ) == "LAVA" ) {
					curOutdoorSectorData.w2floor = W2FT_Incandecent;

				} else if ( floorTexNameLeft5 == "BLOOD" || floorTexNameLeft6 == "NUKAGE" ) {
					curOutdoorSectorData.w2floor = W2FT_Nukage;

				}

				// New group saving:
				w2level.allSectorGroups.Push( W2SectorGroup.Create( nextGroupNum ) );
				nextGroupNum++;
			} // of if ( s.GetTexture( Sector.ceiling ) == skyflatnum ) {}

		} // of for ( int i = 0; i < level.Sectors.Size(); i++ ) {}

		// Understand sectors data for sectors next to under sky:
		for ( int i = 0; i < level.sectors.Size(); i++ ) {
			W2SectorData sdata = w2level.allSectorsData[ i ];

			if ( sdata.w2type == W2ST_NextToOutdoor ) {
				sdata.groupnum = nextGroupNum;
				groupNumsSubstitution.Push( nextGroupNum );

				Sector s = sdata.s;

				for ( int j = 0; j < s.Lines.Size(); j++ ) {
					Line l = s.Lines[ j ];
					Sector lsector = l.frontsector;

					if ( lsector && lsector != s )
						setNextToSillSectorData( lsector );

					lsector = l.backsector;

					if ( lsector && lsector != s )
						setNextToSillSectorData( lsector );
				}

				w2level.allSectorGroups.Push( W2SectorGroup.Create( nextGroupNum ) );
				nextGroupNum++;
			}
		}

		// Backtrace substitution. As far as I calculated, this helps in
		//preventing the "group num degeneration" ("5->4->0", not "5->4->4"):
		for ( int i = groupNumsSubstitution.Size() - 1; i >= 0; i-- )
			groupNumsSubstitution[ i ] = groupNumsSubstitution[ groupNumsSubstitution[ i ] ];

		// Substitute group numbers for sectors under sky & next to them:
		for ( int i = 0; i < level.sectors.Size(); i++ ) {
			W2SectorData sdata = w2level.allSectorsData[ i ];

			if ( sdata.w2type != W2ST_None ) {
				console.printf( "Grouping sector #" .. i .. ". Group " .. sdata.groupnum .. ", subst " .. groupNumsSubstitution[ groupNumsSubstitution[ sdata.groupnum ] ] .. "." );

				if ( sdata.groupnum > groupNumsSubstitution[ sdata.groupnum ] )
					sdata.groupnum = groupNumsSubstitution[ sdata.groupnum ];

				// Linking sector and group with each other:
				W2SectorGroup curgroup = w2level.allSectorGroups[ sdata.groupnum ];
				curgroup.sectors.Push( sdata.s );
				sdata.group = curgroup;
			}
		}

		// Remove excess group numbers and locate a perimeter lines for every megasector:
		for ( int i = 0; i < w2level.allSectorGroups.Size(); i++ ) {
			W2SectorGroup curgroup = w2level.allSectorGroups[ i ];

			if ( !curgroup.sectors.Size() )
				continue;

			w2level.realSectorGroups.Push( curgroup );

			for ( int j = 0; j < curgroup.sectors.Size(); j++ ) {
				Sector cursector = curgroup.sectors[ j ];

				for ( int k = 0; k < cursector.lines.Size(); k++ ) {
					Line curline = cursector.lines[ k ];
					Sector fsec = curline.frontsector;
					Sector bsec = curline.backsector;

					if ( !fsec || !bsec || ( w2level.allSectorsData[ fsec.Index() ].groupnum != w2level.allSectorsData[ bsec.Index() ].groupnum ) ) {
						curgroup.lines.Push( curline );

						//double zspawnpos = ( fsec? ( bsec? max( fsec.floorplane.d, bsec.floorplane.d ) : fsec.floorplane.negiC * fsec.floorplane.d ) : bsec.floorplane.negiC * bsec.floorplane.d );
						//Actor.Spawn( "Unknown", ( curline.v1.p + curline.delta / 2, zspawnpos ) );
					}

				} // of for ( int k = 0; k < cursector.lines.Size(); k++ ) {}
			} // of for ( int j = 0; j < curgroup.sectors.Size(); j++ ) {}

		} // of for ( int i = 0; i < w2level.realSectorGroups.Size(); i++ ) {}


		console.printf( "w2level.realSectorGroups.Size(): " .. w2level.realSectorGroups.Size() .. "." );

		String debugstr = "w2level.realSectorGroups elements:";
		for ( int i = 0; i < w2level.realSectorGroups.Size(); i++ )
			debugstr.AppendFormat( " " .. w2level.realSectorGroups[ i ].num );

		console.printf( debugstr .. "." );


		mustCreateGeneralSectorsData = false;
	} // of override void WorldLoaded( WorldEvent e ) {}


	override void PlayerEntered( PlayerEvent e ) {
		if ( mustCreateGeneralSectorsData )
			CreateGeneralSectorsData();

		if ( players[ e.PlayerNumber ].mo ) {
			W2PlayerHandler playerhandler = W2PlayerHandler( Actor.Spawn( "W2PlayerHandler", players[ e.PlayerNumber ].mo.pos ) );
			playerhandler.FriendPlayer = e.PlayerNumber;
			playerhandler.groupsdata.Copy( w2level.allSectorGroups );
			playerhandler.w2level = w2level;

			playerHandlers[ e.PlayerNumber ] = playerhandler;

			console.printf( "Added a " .. playerhandler.GetClassName() .. " for player " .. e.PlayerNumber .. "." );
		}
		
		Super.PlayerEntered( e );

		/*if ( e.PlayerNumber == consoleplayer && gl_texture_format == "5" ) {
			console.printf( TEXTCOLOR_DARKGRAY .. GetClassName() .. "::PlayerEntered(). " .. TEXTCOLOR_YELLOW
							.. "Your OpenGL texture format seems to be set to \"" .. TEXTCOLOR_CYAN .. "S3TC_DXT3" .. TEXTCOLOR_YELLOW .."\", so translucent raindrops might look weird. " .. TEXTCOLOR_GRAY
							.. "Change it in the \"Display options\"->\"OpenGL renderer\"->\"Texture options\" or alter the \"gl_texture_format\" variable." );
		}*/
	}

	override void WorldTick() {
		if ( players[ consoleplayer ].mo != players[ consoleplayer ].Camera ) {
			vector3 camerapos = players[ consoleplayer ].Camera.pos;
			SendNetworkEvent( "mcm_weathremum_SetCameraXYZ", int( camerapos.x ), int( camerapos.y ), int( camerapos.z ) );

		} else if ( playerHandlers[ consoleplayer ].useMultiplayerPos ) {
			SendNetworkEvent( "mcm_weathremum_CancelCameraXYZ" );

		}

		Super.WorldTick();
	}

	override void NetworkProcess( ConsoleEvent e ) {
		if ( !e.IsManual && multiplayer ) {
			if ( e.Name == "mcm_weathremum_SetCameraXYZ" ) {
				playerHandlers[ e.Player ].useMultiplayerPos = true;
				playerHandlers[ e.Player ].multiplayerPos = ( e.args[ 0 ], e.args[ 1 ], e.args[ 2 ] );
			} else if ( e.Name == "mcm_weathremum_CancelCameraXYZ" ) {
				playerHandlers[ e.Player ].useMultiplayerPos = false;
			}
		}

		/*if ( e.Name ~== "test_turn180" ) {
			players[ e.Player ].mo.angle = ( players[ e.Player ].mo.angle + 180.0 ) % 360.0;
		} else if ( e.Name ~== "test_turnto" ) {
			players[ e.Player ].mo.angle = e.args[ 0 ] % 360.0;
		}*/

		Super.NetworkProcess( e );
	}


	/*override void RenderOverlay( RenderEvent e ) {
		W2PlayerHandler playerhandler = playerHandlers[ consoleplayer ];

		if ( !playerhandler ) {
			Super.RenderOverlay( e );
			return;
		}

		String outStr = "Total active sectors: " .. playerhandler.loopdataindices.Size() .. ".\n";

		for ( int i = 0; i < playerhandler.sectorsdata.Size(); i++ ) {
			W2SectorData cursecdata = playerhandler.sectorsdata[ i ];

			if ( cursecdata.w2type == W2ST_None ) {
				outStr.AppendFormat( TEXTCOLOR_GRAY .. "#%i (g" .. TEXTCOLOR_DARKGRAY .. "%3i" .. TEXTCOLOR_GRAY .. "): ",
									i, cursecdata.groupnum, cursecdata.w2type );
			} else {
				outStr.AppendFormat( TEXTCOLOR_GRAY .. "#%i (g" .. TEXTCOLOR_TEAL .. "%3i" .. TEXTCOLOR_GRAY .. ", t%i): ",
									i, cursecdata.groupnum, cursecdata.w2type );
			}

			switch ( cursecdata.status ) {
				case W2HS_Off:
					outStr = outStr .. TEXTCOLOR_DARKGRAY .. "off\n";
					break;
				case W2HS_Active:
					outStr = outStr .. TEXTCOLOR_GREEN .. "on. " .. TEXTCOLOR_DARKGREEN .. cursecdata.lines.Size() .. " lines ";

					for ( int j = 0; j < cursecdata.lines.Size(); j++ )
						outStr = outStr .. cursecdata.lineindices[ j ] .. " ";

					outStr = outStr .. "\n";
					break;
				case W2HS_StopSuggestion:
					outStr = outStr .. TEXTCOLOR_RED .. "stopping\n";
					break;
				default:
					outStr = outStr .. TEXTCOLOR_FIRE .. "<UNKNOWN>\n";
					console.printf( GetClassName() .. "::RenderOverlay(). " .. TEXTCOLOR_FIRE .. "Unknown data for sector " .. i .. "." );
					break;
			}
		}

		Screen.DrawText( Font.FindFont( "smallfont" ), Font.CR_GRAY, 30, 60, outStr,
						DTA_KeepRatio, true, DTA_VirtualWidth, 1366, DTA_VirtualHeight, 768 );

		W2SectorData secdata = ( playerhandler.floorsector? w2level.allSectorsData[ playerhandler.floorsector.Index() ] : NULL );

		if ( secdata )
			Screen.DrawText( Font.FindFont( "smallfont" ), Font.CR_GRAY, 1100, 100, "Current sector: " .. secdata.s.Index() .. "\nCurrent group: " .. secdata.groupnum,
							DTA_KeepRatio, true, DTA_VirtualWidth, 1366, DTA_VirtualHeight, 768 );

		Super.RenderOverlay( e );
	} */


} // of class mcm_WeathremumHandler: EventHandler {}
