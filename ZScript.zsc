version "2.4.0"

#include "ZScript/W2Data.zsc"
#include "ZScript/W2PlayerHandler.zsc"
#include "ZScript/W2AmbientActors.zsc"

const mcm_WeathremumVersion = "0.1";


class mcm_WeathremumHandler: EventHandler {
	bool mustCreateGeneralSectorsData;		// "PlayerEntered()" is called before "WorldLoaded()".

	Array<W2SectorData> generalSectorsData;	// Just a copyable structure.
	Array<int> corniceLinesFlags;			// For the raindrops effect from a canopy.

	Array<int> groupNumsSubstitution;		// For uniting all neighbour sectors with same "sectype" to same unique "secgroup".
	int nextGroupNum;						// Also for uniting all neighbour sectors. Main work variable.

	W2PlayerHandler firstplayerhandler;		// Temporary debug thing...

	override void OnRegister() {
		SetOrder( WeathremumHandlerOrder );
		mustCreateGeneralSectorsData = true;
		Super.OnRegister();
	}


	private void adjustSectorGroupNum( W2SectorData closeSectorData ) {
		// Uniting all adjacent sectors with same type to one group (in O(1), really!).

		if ( closeSectorData.secgroup == -1 ) {
			closeSectorData.secgroup = nextGroupNum;

		} else if ( closeSectorData.secgroup < groupNumsSubstitution[ nextGroupNum ] ) {
			groupNumsSubstitution[ groupNumsSubstitution[ nextGroupNum ] ] = groupNumsSubstitution[ closeSectorData.secgroup ];
			groupNumsSubstitution[ nextGroupNum ] = groupNumsSubstitution[ closeSectorData.secgroup ];

		} else if ( closeSectorData.secgroup > groupNumsSubstitution[ nextGroupNum ] ) {
			groupNumsSubstitution[ groupNumsSubstitution[ closeSectorData.secgroup ] ] = groupNumsSubstitution[ nextGroupNum ];
			groupNumsSubstitution[ closeSectorData.secgroup ] = groupNumsSubstitution[ nextGroupNum ];
		}
	}

	private void setNextToOutdoorSectorData( Line curline, Sector ls ) {
		W2SectorData closeSectorData = generalSectorsData[ ls.Index() ];

		if ( ls.GetTexture( Sector.ceiling ) != skyflatnum ) {
			closeSectorData.sectype = W2ST_NextToOutdoor;
			corniceLinesFlags[ curline.Index() ] = 1;
		} else {
			adjustSectorGroupNum( closeSectorData );
		}
	}

	private void setNextToSillSectorData( Sector lsector ) {
		W2SectorData closeSectorData = generalSectorsData[ lsector.Index() ];

		if ( closeSectorData.sectype == W2ST_NextToOutdoor )
			adjustSectorGroupNum( closeSectorData );
	}

	void CreateGeneralSectorsData( void ) {
		nextGroupNum = 0;
		groupNumsSubstitution.Clear();

		// Save all of the level sectors and lines for the quick index-based access:
		for ( int i = 0; i < level.lines.Size(); i++ )
			corniceLinesFlags.Push( 0 );

		for ( int i = 0; i < level.sectors.Size(); i++ )
			generalSectorsData.Push( W2SectorData.Create( level.sectors[ i ] ) );

		// Understand sectors data such as "sectype" and "secgroup" for sectors under sky:
		for ( int i = 0; i < level.sectors.Size(); i++ ) {
			//console.printf( "Sector " .. i .. ": " .. level.Sectors[ i ].GetTexture( Sector.ceiling ) .. "." );
			Sector s = level.Sectors[ i ];

			if ( s.GetTexture( Sector.ceiling ) == skyflatnum ) {
				W2SectorData curOutdoorSectorData = generalSectorsData[ i ];

				curOutdoorSectorData.sectype = W2ST_Outdoor;
				curOutdoorSectorData.secgroup = nextGroupNum;
				groupNumsSubstitution.Push( nextGroupNum );

				for ( int j = 0; j < s.Lines.Size(); j++ ) {
					Line l = s.Lines[ j ];
					Sector lsector = l.frontsector;

					if ( lsector && lsector != s )
						setNextToOutdoorSectorData( l, lsector );

					lsector = l.backsector;

					if ( lsector && lsector != s )
						setNextToOutdoorSectorData( l, lsector );
				}

				nextGroupNum++;
			} // of if ( s.GetTexture( Sector.ceiling ) == skyflatnum ) {}

		} // of for ( int i = 0; i < level.Sectors.Size(); i++ ) {}

		// Understand sectors data for sectors next to under sky:
		for ( int i = 0; i < level.sectors.Size(); i++ ) {
			W2SectorData sdata = generalSectorsData[ i ];

			if ( sdata.sectype == W2ST_NextToOutdoor ) {
				sdata.secgroup = nextGroupNum;
				groupNumsSubstitution.Push( nextGroupNum );

				Sector s = sdata.s;

				for ( int j = 0; j < s.Lines.Size(); j++ ) {
					Line l = s.Lines[ j ];
					Sector lsector = l.frontsector;

					// "s" isn't a NULL anyway.
					if ( lsector && lsector != s )
						setNextToSillSectorData( lsector );

					lsector = l.backsector;

					if ( lsector && lsector != s )
						setNextToSillSectorData( lsector );
				}

				nextGroupNum++;
			}
		}

		// Substitute group numbers for sectors under sky & next to them:
		for ( int i = 0; i < level.sectors.Size(); i++ ) {
			W2SectorData sdata = generalSectorsData[ i ];

			if ( sdata.sectype != W2ST_None ) {
				console.printf( "Grouping sector #" .. i .. ". Group " .. sdata.secgroup .. ", subst " .. groupNumsSubstitution[ groupNumsSubstitution[ sdata.secgroup ] ] .. "." );

				if ( sdata.secgroup > groupNumsSubstitution[ groupNumsSubstitution[ sdata.secgroup ] ] )
					sdata.secgroup = groupNumsSubstitution[ groupNumsSubstitution[ sdata.secgroup ] ];
			}
		}

		mustCreateGeneralSectorsData = false;
	} // of override void WorldLoaded( WorldEvent e ) {}


	override void PlayerEntered( PlayerEvent e ) {
		if ( mustCreateGeneralSectorsData )
			CreateGeneralSectorsData();

		if ( players[ e.PlayerNumber ].mo ) {
			W2PlayerHandler playerhandler = W2PlayerHandler( Actor.Spawn( "W2PlayerHandler", players[ e.PlayerNumber ].mo.pos ) );
			playerhandler.FriendPlayer = e.PlayerNumber;
			playerhandler.sectorsdata.Copy( generalSectorsData );
			playerhandler.w2handler = self;

			if ( e.PlayerNumber == 0 )
				firstplayerhandler = playerhandler;

			console.printf( "Added a " .. playerhandler.GetClassName() .. " for player " .. e.PlayerNumber .. "." );
		}
		
		Super.PlayerEntered( e );

		if ( e.PlayerNumber == consoleplayer && gl_texture_format == "5" ) {
			console.printf( TEXTCOLOR_DARKGRAY .. GetClassName() .. "::PlayerEntered(). " .. TEXTCOLOR_YELLOW
							.. "Your OpenGL texture format seems to be set to \"" .. TEXTCOLOR_CYAN .. "S3TC_DXT3" .. TEXTCOLOR_YELLOW .."\", so translucent raindrops might look weird. " .. TEXTCOLOR_GRAY
							.. "Change it in the \"Display options\"->\"OpenGL renderer\"->\"Texture options\" or alter the \"gl_texture_format\" variable." );
		}
	}

	/*override void RenderOverlay( RenderEvent e ) {
		if ( !firstplayerhandler ) {
			Super.RenderOverlay( e );
			return;
		}

		String outStr = "Total active sectors: " .. firstplayerhandler.loopdataindices.Size() .. ".\n";

		for ( int i = 0; i < firstplayerhandler.sectorsdata.Size(); i++ ) {
			W2SectorData cursecdata = firstplayerhandler.sectorsdata[ i ];

			if ( cursecdata.sectype == W2ST_None ) {
				outStr.AppendFormat( TEXTCOLOR_GRAY .. "#%i (g" .. TEXTCOLOR_DARKGRAY .. "%3i" .. TEXTCOLOR_GRAY .. "): ",
									i, cursecdata.secgroup, cursecdata.sectype );
			} else {
				outStr.AppendFormat( TEXTCOLOR_GRAY .. "#%i (g" .. TEXTCOLOR_TEAL .. "%3i" .. TEXTCOLOR_GRAY .. ", t%i): ",
									i, cursecdata.secgroup, cursecdata.sectype );
			}

			switch ( cursecdata.status ) {
				case W2HS_Off:
					outStr = outStr .. TEXTCOLOR_DARKGRAY .. "off\n";
					break;
				case W2HS_Active:
					outStr = outStr .. TEXTCOLOR_GREEN .. "on. " .. TEXTCOLOR_DARKGREEN .. cursecdata.lines.Size() .. " lines ";

					for ( int j = 0; j < cursecdata.lines.Size(); j++ )
						outStr = outStr .. cursecdata.lineindices[ j ] .. " ";

					outStr = outStr .. "\n";
					break;
				case W2HS_StopSuggestion:
					outStr = outStr .. TEXTCOLOR_RED .. "stopping\n";
					break;
				default:
					outStr = outStr .. TEXTCOLOR_FIRE .. "<UNKNOWN>\n";
					console.printf( GetClassName() .. "::RenderOverlay(). " .. TEXTCOLOR_FIRE .. "Unknown data for sector " .. i .. "." );
					break;
			}
		}

		Screen.DrawText( Font.FindFont( "smallfont" ), Font.CR_GRAY, 30, 60, outStr,
						DTA_KeepRatio, true, DTA_VirtualWidth, 1366, DTA_VirtualHeight, 768 );

		Screen.DrawText( Font.FindFont( "smallfont" ), Font.CR_GRAY, 1100, 60, "Current sector: " .. ( firstplayerhandler.floorsector? firstplayerhandler.floorsector.sectornum .. "" : "NULL" ),
						DTA_KeepRatio, true, DTA_VirtualWidth, 1366, DTA_VirtualHeight, 768 );

		Super.RenderOverlay( e );
	}*/

} // of class mcm_WeathremumHandler: EventHandler {}
