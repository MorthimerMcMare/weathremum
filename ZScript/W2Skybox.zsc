// All of the Weathremum skybox stuff.

class W2BaseSkyActor: Actor abstract {
	W2SkyboxViewpoint skycam;
	vector3 sphericaloffset; //double ra, decl, dist;

	Default {
		+NOINTERACTION;
		+NOTONAUTOMAP;
		+BRIGHT;
	}

	static clearscope vector3 vector3ToSpherical( vector3 vec ) {
		return (atan2( vec.y, vec.x ), -90.0 * sin( vec.z ), vec.length());

		// Real spherical (not RA/Decl) coords calc:
		//double r = vec.length();
		//return (atan2( vec.y, vec.x ), acos( vec.z / r ), r);
	}

	static clearscope vector3 sphericalToVector3( vector3 spherical ) {
		double cosangle = cos( spherical.x );
		double cospitch = cos( spherical.y );

		return (cosangle * cospitch, sin( spherical.x ) * cospitch, sin( spherical.y )) * spherical.z;

		// Real spherical (not RA/Decl) coords calc:
		/*double cosphi = cos( spherical.x );
		double sinphi = sin( spherical.x );
		double costheta = cos( spherical.y );
		double sintheta = sin( spherical.y );

		return spherical.z * (cosphi * sintheta, sinphi * sintheta, costheta);*/
	}

	void AddOrigin( vector3 vec3pos ) {
		sphericaloffset = vector3ToSpherical( sphericalToVector3( sphericaloffset ) + vec3pos );
	}

	override void PostBeginPlay() {
		if ( !skycam )
			Destroy();
	}

	/*static double, double vector3ToAnglePitch( vector3 vec ) {
		return atan2( vec.y, vec.x ), -atan2( vec.z, vec.xy.length() );
	}

	static vector3 anglePitchToVector3( double angle, double pitch ) {
		double cosangle = cos( angle );
		double cospitch = cos( pitch );

		return (cosangle * cospitch, sin( angle ) * cospitch, sin( pitch ));
	}*/

} // of class W2BaseSkyActor: Actor abstract {}

class W2StaticSkyActor: W2BaseSkyActor abstract {
	States {
	Spawn:
		TROO A -1;
		Stop;
	}

	override void Tick() {
		SetZ( skycam.pos.z + sphericaloffset.z * cos( sphericaloffset.y ) );
	}
} // of class W2StaticSkyActor: W2BaseSkyActor abstract {}

class W2DynamicSkyActor: W2BaseSkyActor abstract {
	Default {
		RenderStyle "Translucent";
	}

	override void Tick() {
		SetOrigin( skycam.pos + sphericalToVector3( sphericaloffset ), true );
		Super.Tick();
	}
} // of class W2DynamicSkyActor: W2BaseSkyActor abstract {}


class W2SkyboxViewpoint: SkyViewpoint {
	Array<W2BaseSkyActor> skyboxActors;

	double realangle;

	static W2SkyboxViewpoint Create( int playernum ) {
		W2SkyboxViewpoint newskies = W2SkyboxViewpoint( Actor.Spawn( "W2SkyboxViewpoint", (0, 0, 0) ) );

		newskies.FriendPlayer = clamp( playernum, 0, MAXPLAYERS );
		newskies.master = ( playeringame[ playernum ] && players[ playernum ].mo )? players[ playernum ].mo : NULL;

		// Don't sure why exactly that coordinates, but skybox on specified 
		//constants not vanishes temporarely on some player angles/pitches.
		newskies.SetOrigin( (50000, 0, 0), false );
		newskies.SetZ( newskies.floorz );

		newskies.bNOINTERACTION = true;
		//newskies.UnlinkFromWorld();

		if ( newskies.master )
			newskies.realangle = -newskies.master.angle;

		return newskies;
	}

	override void Tick() {
		if ( !master ) {
			W2Global.Log( LL_Detailed, GetClassName() .. "::Tick(). No master (player), destroying self." );
			Destroy();

		} else {
			// === For Doom 2, this works fine for all levels with skies, 
			//except MAP23 and MAP29. Only one side is visible:
			double prevangle = realangle;
			realangle -= master.player.cmd.yaw * ( 360.0 / 65536.0 );

			vector3 outOfBoundsPos = pos;
			double oldPosZ = outOfBoundsPos.z;

			SetOrigin( master.pos, false );
			//UnlinkFromWorld();
			//SetXYZ( master.pos );
			//FindFloorCeiling();
			//LinkToWorld();
			outOfBoundsPos.z = master.cursector.floorplane.ZatPoint( master.pos.xy );

			SetXYZ( outOfBoundsPos );
			ClearInterpolation();

			//console.printf( "skyboxActors.Size() at time %i: %i.", level.maptime, skyboxActors.Size() );

			if ( pos.z != oldPosZ ) {
				//console.printf( "Skybox floorsector: " .. floorsector .. ", cursector: " .. cursector );

				//angle = realangle;
				//ClearInterpolation();

				for ( int i = 0; i < skyboxActors.Size(); i++ ) {
					W2BaseSkyActor curactor = skyboxActors[ i ];

					if ( curactor ) {

						//curactor.sphericaloffset.x = ( curactor.sphericaloffset.x + realangle - prevangle ) % 360.0;
						//curactor.AddOrigin( (0.0, 0.0, oldPosZ - pos.z ) );
						curactor.SetZ( pos.z + curactor.sphericaloffset.z * sin( curactor.sphericaloffset.y ) );
						curactor.ClearInterpolation();
					} else {
						W2Global.Log( LL_Emergency, GetClassName() .. "::Tick(). Maptime " .. level.maptime .. "; skyboxActors[ " .. i .. " ] == NULL. skyboxActors.Size() " .. skyboxActors.Size() );
					}
				} // of for ( int i = 0; i < skyboxActors.Size(); i++ ) {}

			} // of if ( pos.z != oldPosZ ) {}

		}
	} // of override void Tick() {}

	W2BaseSkyActor, uint CreateActor( class<W2BaseSkyActor> cls, vector3 thingCartesianOffset ) {
		W2BaseSkyActor skyactor = W2BaseSkyActor( Actor.Spawn( cls, pos + thingCartesianOffset ) );
		skyactor.skycam = self;
		skyactor.sphericaloffset = W2BaseSkyActor.vector3ToSpherical( thingCartesianOffset );

		int pushedIndex = skyboxActors.Push( skyactor );

		return skyactor, pushedIndex;
	}

	W2BaseSkyActor, uint CreateActorSpherical( class<W2BaseSkyActor> cls, vector3 thingSphericalOffset ) {
		W2BaseSkyActor skyactor = W2BaseSkyActor( Actor.Spawn( cls, pos + W2BaseSkyActor.sphericalToVector3( thingSphericalOffset ) ) );
		skyactor.skycam = self;
		skyactor.sphericaloffset = thingSphericalOffset;

		int pushedIndex = skyboxActors.Push( skyactor );

		return skyactor, pushedIndex;
	}

	W2BaseSkyActor CreateUnlinkedActor( class<W2BaseSkyActor> cls, vector3 thingCartesianOffset ) {
		W2BaseSkyActor skyactor = W2BaseSkyActor( Actor.Spawn( cls, pos + thingCartesianOffset ) );
		skyactor.skycam = self;
		skyactor.sphericaloffset = W2BaseSkyActor.vector3ToSpherical( thingCartesianOffset );

		return skyactor;
	}


	void Clear() {
		for ( int i = 0; i < skyboxActors.Size(); i++ )
			skyboxActors[ i ].Destroy();

		Super.OnDestroy();
	}

	override void OnDestroy() {
		LinkToWorld();
		Super.OnDestroy();
	}
} // of class W2SkyboxViewpoint: SkyViewpoint {}


class W2SkyboxFog: W2DynamicSkyActor {
	enum ESkyboxFogType {
		SFT_Mist 	= 0,
		SFT_Light 	= 1,
		SFT_Dark 	= 2,
		SFT_Sun		= 3
	};

	Default {
		RenderStyle "Translucent";
		Alpha 0.1;
	}

	void SetType( ESkyboxFogType newtype, double newalpha = -0.1 ) {
		frame = newtype;

		if ( newalpha >= 0.0 )
			alpha = min( newalpha, 1.0 );
	}

	/*override void Tick() {
		//sphericaloffset.x += 1.0;
		//sphericaloffset.y += sin( level.maptime / 70.0 );
		//AddVec3Pos( ( sin( level.maptime / 1000.0 ) * 20.0, 0, 0 ) );
		Super.Tick();
	}*/

	States {
	Spawn:
		TROO A -1;
		Stop;
	}
} // of class W2SkyboxFog: W2DynamicSkyActor {}


class W2NightOceanSkybox: W2StaticSkyActor {
}

class W2Galaxy1Skybox: W2StaticSkyActor {
}


class W2SkyboxSmallStar: W2DynamicSkyActor {
	Default {
		+FORCEXYBILLBOARD;
	}

	int delayModulo;
	double theta, thetaGradient;

	override void PostBeginPlay() {
		Super.PostBeginPlay();
		scale.x = scale.y = FRandom( 0.2, 1.5 );

		delayModulo = Random( 5, 35 );
		theta = FRandom( 0.0, 360.0 );
		thetaGradient = FRandom( 1.0, 15.0 );
	}

	override void Tick() {
		if ( !( level.time % delayModulo ) ) {
			theta += thetaGradient;
			alpha = clamp( sin( theta ), 0.05, 1.0 );
		}

		//Super.Tick();
	}

	States {
	Spawn:
		STAR "[" -1;
		Stop;
	}
}
