// Weathremum handler for each player.

class W2PlayerHandler: Actor {
	bool useMultiplayerPos;
	vector3 multiplayerPos;

	W2LevelGeneralData w2level;

	Array<W2SectorGroup> groupsdata;// All of the level sectors saved for the quick access. This is separated from global definition for the optimization in multiplayer.
	Array<int> loopdataindices;		// Array storing currently playing sector groups.
	Array<int> newdataindices;		// Temporary array with group data updates.
	Array<Line> corniceLines;		// Lines between outdoor and indoor areas.

	// "target" is an actor to follow (updates every "Tick()").

	Default {
		+NOINTERACTION; // Implies +NOGRAVITY and +NOBLOCKMAP.
		+DONTSPLASH;
		+NOTONAUTOMAP;
	}

	override void BeginPlay() {
		useMultiplayerPos = false;
	}

	private W2SectorGroup TryAddSectorGroup( Sector s ) {
		if ( !s )
			return NULL;

		int groupnum = w2level.allSectorsData[ s.Index() ].groupnum;
		if ( groupnum < 0 )
			return NULL;

		W2SectorGroup groupdata = groupsdata[ groupnum ];

		// Starts sector sound or continues it (by stop preventing) if it is still needed.
		if ( groupdata.status == W2HS_Off )
			newdataindices.Push( groupnum );

		if ( groupdata.status != W2HS_Active ) {
			groupdata.status = W2HS_Active;
			groupdata.lines.Clear();
		}

		return groupdata;
	}

	void DoSectorEffects( void ) {
		// Suggest potential excess sounds to stop:
		for ( int i = 0; i < loopdataindices.Size(); i++ )
			groupsdata[ loopdataindices[ i ] ].status = W2HS_StopSuggestion;

		newdataindices.Clear();
		corniceLines.Clear();

		// Second argument is an environment test radius.
		BlockLinesIterator it = BlockLinesIterator.Create( self, 768 );

		// Saving all of the surrounding sectors and defining a canopy raindrops:
		while ( it.Next() ) {
			Line l = it.curline;
			W2SectorGroup groupdata = NULL;

			if ( groupdata = TryAddSectorGroup( l.frontsector ) ) {
				groupdata.lines.Push( l );
				//groupdata.lineindices.Push( l.Index() );
			}

			if ( groupdata = TryAddSectorGroup( l.backsector ) ) {
				groupdata.lines.Push( l );
				//groupdata.lineindices.Push( l.Index() );
			}

			// "Actor.Spawn()" violates "BlockLinesIterator" work because of interference to "validcount" variable.
			if ( w2level.corniceLinesFlags[ l.Index() ] == 1 )
				corniceLines.Push( l );
		} // of while ( it.Next() ) {}

		TryAddSectorGroup( ceilingsector );
		// I think there's no matter to use the floorsector field.


		// Wiping sounds from too far sector groups:
		for ( int i = 0; i < loopdataindices.Size(); i++ ) {
			W2SectorGroup groupdata = groupsdata[ loopdataindices[ i ] ];

			// Clearing excess sound origins:
			if ( groupdata.status == W2HS_StopSuggestion ) {
				//console.printf( TEXTCOLOR_DARKRED .. "-Stopped\c- sound for sector " .. loopdataindices[ i ] .. "." );
				if ( groupdata.soundorigin )
					groupdata.soundorigin.Destroy();

				groupdata.status = W2HS_Off;

				loopdataindices.Delete( i );
				i--;
			}
		}

		// Creating new sound actors and pushing their sector groups to the time-through array:
		for ( int i = 0; i < newdataindices.Size(); i++ ) {
			W2SectorGroup groupdata = groupsdata[ newdataindices[ i ] ];

			if ( w2level.allSectorsData[ groupdata.sectors[ 0 ].Index() ].w2type != W2ST_None ) {
				W2SoundOrigin sndactor = groupdata.soundorigin = W2SoundOrigin( Actor.Spawn( "W2SoundOrigin", ( groupdata.lines[ 0 ].v1.p, groupdata.sectors[ 0 ].floorplane.d ) ) );
				sndactor.master = self;
				sndactor.target = target; // Player or his camera.
				sndactor.justCreated = true;

				//console.printf( TEXTCOLOR_GREEN .. "+Started\c- sound for sector " .. newdataindices[ i ] .. "." );

				switch ( w2level.allSectorsData[ groupdata.sectors[ 0 ].Index() ].w2type ) {
					case W2ST_Outdoor:
						sndactor.seq = sndactor.StartSoundSequence( "weather/rain", SeqNode.ENVIRONMENT );
						break;
					case W2ST_NextToOutdoor:
						sndactor.seq = sndactor.StartSoundSequence( "weather/wind", SeqNode.ENVIRONMENT );
						break;
					default:
						break;
				}
			}

			// Saving new active sector groups.
			loopdataindices.Push( newdataindices[ i ] );
		}

		// Moving all the sound origins to their new positions:
		for ( int i = 0; i < loopdataindices.Size(); i++ ) {
			W2SectorGroup groupdata = groupsdata[ loopdataindices[ i ] ];

			if ( !groupdata.soundorigin )
				continue;

			W2SoundOrigin sndactor = groupdata.soundorigin;

			// Moving sound origins:
			if ( w2level.allSectorsData[ floorsector.Index() ].groupnum == groupdata.num ) {
				sndactor.SetOrigin( ( Vec2Angle( sndactor.intersectionOffset.Length(), sndactor.intersectionAngle + angle ), sndactor.floorz ), true );
				//sndactor.interpMaxTics = sndactor.interpTic = 15;
			} else {
				vector2 minposxy;
				double minlength = 1e300; // Really must be greater than an environment test radius.

				vector2 plp = pos.xy;

				for ( int j = 0; j < groupdata.lines.Size(); j++ ) {
					Line curline = groupdata.lines[ j ];
					double curminlength = 1e304;
					vector2 curposxy;

					vector2 v1p = curline.v1.p;
					vector2 v2p = curline.v2.p;

					if ( ( (v1p - plp) dot (v1p - v2p) <= 0.0 ) || ( (v2p - plp) dot (v2p - v1p) <= 0.0 ) ) {
						double length1 = ( plp - v1p ).Length();
						double length2 = ( plp - v2p ).Length();

						if ( length1 < length2 ) {
							curminlength = length1;
							curposxy = v1p;
						} else {
							curminlength = length2;
							curposxy = v2p;
						}

					} else {
						double dlx = curline.delta.x;
						double dly = curline.delta.y;

						if ( dlx == 0 ) {
							curposxy = (v1p.x, pos.y);

						} else if ( dly == 0 ) {
							curposxy = (pos.x, v1p.y);

						} else {
							curposxy.y = (dlx * (v1p.y * (dlx/dly) - v1p.x + pos.x) + dly*pos.y)/((dlx * dlx/dly) + dly);
							curposxy.x = (curposxy.y - v1p.y) * (dlx / dly) + v1p.x;
						}

						curminlength = ( curposxy - plp ).Length();
					}

					if ( curminlength < minlength ) {
						minlength = curminlength;
						minposxy = curposxy;
					}

				} // of for ( int j = 0; j < groupdata.lines.Size(); j++ ) {}

				sndactor.LinedefMove( minposxy );

				sndactor.intersectionOffset = ( sndactor.pos.xy - pos.xy );
				sndactor.intersectionAngle = atan2( sndactor.intersectionOffset.y, sndactor.intersectionOffset.x ) - angle;
			}

			sndactor.justCreated = false;

		} // of for ( int i = 0; i < loopdataindices.Size(); i++ ) {}

	} // of void DoSectorEffects( void ) {}


	void DoRainEffects( void ) {
		// For the cumulative distribution function "sqrt()" addition 
		//thanks to https://habr.com/ru/post/583838/.

		// Outdoor areas raindrop effect:
		for ( int i = 0; i < 200; i++ ) {
			double angletheta = FRandom( 0.0, 360.0 );

			vector2 raindropPos = pos.xy + ( cos( angletheta ), sin( angletheta ) ) * ( 8.0 + sqrt( FRandom( 0.0, 1.0 ) ) * 764.0 );

			Weathremum_Raindrop raindrop = Weathremum_Raindrop( Actor.Spawn( "Weathremum_Raindrop", ( raindropPos, pos.z ) ) );
			raindrop.target = target;
			raindrop.master = self;
			raindrop.w2sector = w2level.allSectorsData[ raindrop.cursector.Index() ];

			//raindrop.vel.xy = ( 10.0, 10.0 ) * ( sin( rainwaveOffset ) + 1.0 );
		}

		// Cornice raindrops effect:
		for ( int i = 0; i < corniceLines.Size(); i++ ) {
			Line l = corniceLines[ i ];
			double linelength = l.delta.Length();

			double minspawnheight = ( l.frontsector? l.frontsector.ceilingplane.d : 1e300 );

			if ( l.backsector && ( l.backsector.ceilingplane.d < minspawnheight ) )
				minspawnheight = l.backsector.ceilingplane.d;

			if ( !Random( 0, 1 ) ) {
				Actor raindrop = Actor.Spawn( "Weathremum_CanopyRaindrop", ( l.v1.p + l.delta / linelength * FRandom( 0.0, linelength ), minspawnheight ) );
				raindrop.master = target;
			}
		}
	} // of void DoRainEffects( void ) {}


	override void Tick() {
		PlayerInfo pl = players[ FriendPlayer ];

		if ( bDORMANT || !playeringame[ FriendPlayer ] || !pl.mo || globalfreeze || level.frozen )
			return;

		target = pl.mo;

		vector3 newpos;

		if ( !multiplayer )
			newpos = ( pl.Camera? pl.Camera.pos : target.pos );
		else
			newpos = ( useMultiplayerPos? multiplayerPos : target.pos );

		//console.printf( "W2PlH <" .. self .. "> target: <" .. target .. "> (Frnd <" .. pl.mo .. ">), useMultipl " .. useMultiplayerPos .. "-> " .. newpos );

		// Move the handler actor to the camera position:
		SetOrigin( newpos, true );
		angle = target.angle; // Singleplayer-aware!!


		// Sector sounds (rain, winds):
		DoSectorEffects();

		// Rain itself, raindrops from cornices:
		DoRainEffects();

		Super.Tick();
	}

} // of class W2PlayerHandler: Actor {}

