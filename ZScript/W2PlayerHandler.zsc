// Weathremum handler for each player.

class W2PlayerHandler: Actor {
	bool useMultiplayerPos;
	vector3 multiplayerPos;

	W2LevelGeneralData w2level;

	Array<W2SoundKeeper> sndkeepers;
	Array<Line> corniceLines;			// Lines between outdoor and indoor areas.

	// "target" is an actor to follow (updates every "Tick()").

	Default {
		+NOINTERACTION; // Implies +NOGRAVITY and +NOBLOCKMAP.
		+DONTSPLASH;
		+NOTONAUTOMAP;
	}

	override void BeginPlay() {
		useMultiplayerPos = false;
	}


	void DoSectorEffects( void ) {
		corniceLines.Clear();

		EWeathremumSectorType tCursector = W2ST_None;

		if ( ceilingsector ) {
			tCursector = w2level.allSectorsData[ ceilingsector.Index() ].w2type;

			if ( tCursector != W2ST_None ) {
				sndkeepers[ tCursector ].SuggestPos( pos.xy + ( 6.0, 0.0 ), W2SD_Left );
				sndkeepers[ tCursector ].SuggestPos( pos.xy + ( 6.0, 0.0 ), W2SD_Right );
			}
		}


		// Second argument is an environment test radius.
		BlockLinesIterator it = BlockLinesIterator.Create( self, 768 );

		while ( it.Next() ) {
			Line l = it.curline;

			//int a = 0.123456; // Last part of the next line is for debug:
			if ( !l.frontsector /*|| ( l.frontsector.Index() != 11 )*/ )
				continue;

			EWeathremumSectorType tfront = ( l.frontsector? w2level.allSectorsData[ l.frontsector.Index() ].w2type : W2ST_None );
			EWeathremumSectorType tback = ( l.backsector? w2level.allSectorsData[ l.backsector.Index() ].w2type : W2ST_None );

			// Try to find a minimal length for the current sound:
			if ( tfront != W2ST_None && tfront != tCursector )
				sndkeepers[ tfront ].SuggestLine( l );

			if ( tback != W2ST_None && tback != tfront && tback != tCursector )
				sndkeepers[ tback ].SuggestLine( l );

			// "Actor.Spawn()" violates "BlockLinesIterator" work because of interference to the "validcount" variable.
			if ( w2level.corniceLinesFlags[ l.Index() ] == 1 )
				corniceLines.Push( l );
		} // of while ( it.Next() ) {}

	} // of void DoSectorEffects( void ) {}


	void DoRainEffects( void ) {
		// For the cumulative distribution function "sqrt()" addition 
		//thanks to https://habr.com/ru/post/583838/.

		// Outdoor areas raindrop effect:
		for ( int i = 0; i < 250; i++ ) {
			double angletheta = FRandom( 0.0, 360.0 );

			vector2 raindropPos = pos.xy + ( cos( angletheta ), sin( angletheta ) ) * ( 8.0 + sqrt( FRandom( 0.0, 1.0 ) ) * 764.0 );

			Weathremum_Raindrop raindrop = Weathremum_Raindrop( Actor.Spawn( "Weathremum_Raindrop", ( raindropPos, pos.z ) ) );
			raindrop.target = target;
			raindrop.master = self;
			raindrop.w2sector = w2level.allSectorsData[ raindrop.cursector.Index() ];

			//raindrop.vel.xy = ( 10.0, 10.0 ) * ( sin( rainwaveOffset ) + 1.0 );
		}

		// Cornice raindrops effect:
		for ( int i = 0; i < corniceLines.Size(); i++ ) {
			Line l = corniceLines[ i ];
			double linelength = l.delta.Length();

			double minspawnheight = ( l.frontsector? l.frontsector.ceilingplane.d : 1e300 );

			if ( l.backsector && ( l.backsector.ceilingplane.d < minspawnheight ) )
				minspawnheight = l.backsector.ceilingplane.d;

			double spawnCoef = linelength / 96.0;

			int spawnAmount = int( floor( spawnCoef ) );
			double extraSpawnChange = spawnCoef - spawnAmount;

			if ( extraSpawnChange > 0.0 && FRandom( 0.0, 1.0 ) < extraSpawnChange )
				spawnAmount++;

			for ( int i = 0; i < spawnAmount; i++ ) {
				Actor raindrop = Actor.Spawn( "Weathremum_CanopyRaindrop", ( l.v1.p + l.delta / linelength * FRandom( 0.0, linelength ), minspawnheight ) );
				raindrop.master = target;
			}
		}
	} // of void DoRainEffects( void ) {}


	override void Tick() {
		PlayerInfo pl = players[ FriendPlayer ];

		if ( bDORMANT || !playeringame[ FriendPlayer ] || !pl.mo || FriendPlayer != consoleplayer || globalfreeze || level.frozen )
			return;

		target = pl.mo;

		if ( !target ) {
			W2Global.Log( LL_Main, GetClassName() .. "::Tick(). Target player " .. FriendPlayer .. " disappeared, destroying self." );
			Destroy();
			Super.Tick();
		}

		vector3 newpos;

		if ( !multiplayer )
			newpos = ( pl.Camera? pl.Camera.pos : target.pos );
		else
			newpos = ( useMultiplayerPos? multiplayerPos : target.pos );

		//console.printf( "W2PlH <" .. self .. "> target: <" .. target .. "> (Frnd <" .. pl.mo .. ">), useMultipl " .. useMultiplayerPos .. "-> " .. newpos );

		// Move the handler actor to the camera position:
		SetOrigin( newpos, true );
		angle = target.angle; // Singleplayer-aware!!


		// Sound keepers pre-tick handling:
		for ( int i = 0; i < sndkeepers.Size(); i++ )
			sndkeepers[ i ].PreTick();

		DoSectorEffects(); 	// Sector sounds (rain, winds);
		DoRainEffects(); 	// Rain itself, raindrops from cornices.

		// Sound keepers post-tick handling:
		for ( int i = 0; i < sndkeepers.Size(); i++ )
			sndkeepers[ i ].PostTick();

		//int a = 0.123456; // Next line is for debug (uncomment lines above):
		//sndkeepers[ W2ST_NormalSurface ].PostTick();

		Super.Tick();
	}

} // of class W2PlayerHandler: Actor {}
