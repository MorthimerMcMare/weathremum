// Weathremum handler for each player.

/*class tempLeftRightMarker: Actor {
	// Used for the stereo sound playing debug.
	Default {
		+NOINTERACTION;
		+DONTSPLASH;
		RenderStyle "Translucent";
		Alpha 0.44;
	}

	States {
	Spawn:
		SPKR A 2;
		Stop;
	}
}*/

class W2PlayerHandler: Actor {
	bool useMultiplayerPos;
	vector3 multiplayerPos;

	W2LevelGeneralData w2level;

	Array<W2SectorGroup> groupsdata;// All of the level sectors saved for the quick access. This is separated from global definition for the optimization in multiplayer.
	Array<int> loopdataindices;		// Array storing currently playing sector groups.
	Array<int> newdataindices;		// Temporary array with group data updates.
	Array<Line> corniceLines;		// Lines between outdoor and indoor areas.

	// "target" is an actor to follow (updates every "Tick()").

	Default {
		+NOINTERACTION; // Implies +NOGRAVITY and +NOBLOCKMAP.
		+DONTSPLASH;
		+NOTONAUTOMAP;
	}

	override void BeginPlay() {
		useMultiplayerPos = false;
	}

	private W2SectorGroup TryAddSectorGroup( Sector s ) {
		if ( !s )
			return NULL;

		int groupnum = w2level.allSectorsData[ s.Index() ].groupnum;
		if ( groupnum < 0 )
			return NULL;

		W2SectorGroup groupdata = groupsdata[ groupnum ];

		// Starts sector sound or continues it (by stop preventing) if it is still needed.
		if ( groupdata.status == W2HS_Off )
			newdataindices.Push( groupnum );

		if ( groupdata.status != W2HS_Active ) {
			groupdata.status = W2HS_Active;
			groupdata.lines.Clear();
		}

		return groupdata;
	}

	void DoSectorEffects( void ) {
		// Suggest potential excess sounds to stop:
		for ( int i = 0; i < loopdataindices.Size(); i++ )
			groupsdata[ loopdataindices[ i ] ].status = W2HS_StopSuggestion;

		newdataindices.Clear();
		corniceLines.Clear();

		// Second argument is an environment test radius.
		BlockLinesIterator it = BlockLinesIterator.Create( self, 768 );

		// Saving all of the surrounding sectors and defining a canopy raindrops:
		while ( it.Next() ) {
			Line l = it.curline;
			W2SectorGroup groupdata = NULL;

			if ( groupdata = TryAddSectorGroup( l.frontsector ) ) {
				groupdata.lines.Push( l );
				//groupdata.lineindices.Push( l.Index() );
			}

			if ( groupdata = TryAddSectorGroup( l.backsector ) ) {
				groupdata.lines.Push( l );
				//groupdata.lineindices.Push( l.Index() );
			}

			// "Actor.Spawn()" violates "BlockLinesIterator" work because of interference to "validcount" variable.
			if ( w2level.corniceLinesFlags[ l.Index() ] == 1 )
				corniceLines.Push( l );
		} // of while ( it.Next() ) {}

		TryAddSectorGroup( ceilingsector );
		// I think there's no matter to use the floorsector field.


		// Wiping sounds from too far sector groups:
		for ( int i = 0; i < loopdataindices.Size(); i++ ) {
			W2SectorGroup groupdata = groupsdata[ loopdataindices[ i ] ];

			// Clearing excess sound origins:
			if ( groupdata.status == W2HS_StopSuggestion ) {
				//console.printf( TEXTCOLOR_DARKRED .. "-Stopped\c- sound for sector " .. loopdataindices[ i ] .. "." );
				for ( int j = 0; j < W2SD_Quantity; j++ )
					if ( groupdata.sndorigin[ j ] )
						groupdata.sndorigin[ j ].Destroy();

				groupdata.status = W2HS_Off;

				loopdataindices.Delete( i );
				i--;
			}
		}

		// Creating new sound actors and pushing their sector groups to the time-through array:
		for ( int i = 0; i < newdataindices.Size(); i++ ) {
			W2SectorGroup groupdata = groupsdata[ newdataindices[ i ] ];

			if ( w2level.allSectorsData[ groupdata.sectors[ 0 ].Index() ].w2type != W2ST_None ) {

				for ( int j = 0; j < W2SD_Quantity; j++ ) {
					W2SoundOrigin sndactor = groupdata.sndorigin[ j ] = W2SoundOrigin( Actor.Spawn( "W2SoundOrigin", ( groupdata.lines[ 0 ].v1.p, groupdata.sectors[ 0 ].floorplane.d ) ) );
					sndactor.master = self;
					sndactor.target = target; // Player or his camera.
					sndactor.justCreated = true;

					//console.printf( TEXTCOLOR_GREEN .. "+Started\c- sound for sector " .. newdataindices[ i ] .. "." );

					switch ( w2level.allSectorsData[ groupdata.sectors[ 0 ].Index() ].w2type ) {
						case W2ST_Outdoor:
							sndactor.seq = sndactor.StartSoundSequence( "weather/rain", SeqNode.ENVIRONMENT );
							break;
						case W2ST_NextToOutdoor:
							sndactor.seq = sndactor.StartSoundSequence( "weather/wind", SeqNode.ENVIRONMENT );
							break;
						default:
							break;
					}

				} // of for ( int j = 0; j < W2SD_Quantity; j++ ) {}
			}

			// Saving new active sector groups.
			loopdataindices.Push( newdataindices[ i ] );
		}

		// Moving all the sound origins to their new positions:
		for ( int i = 0; i < loopdataindices.Size(); i++ ) {
			W2SectorGroup groupdata = groupsdata[ loopdataindices[ i ] ];

			if ( !groupdata.sndorigin[ 0 ] )
				continue;

			W2SoundOrigin sndleft = groupdata.sndorigin[ W2SD_Left ];
			W2SoundOrigin sndright = groupdata.sndorigin[ W2SD_Right ];

			// Moving sound origins:
			if ( w2level.allSectorsData[ floorsector.Index() ].groupnum == groupdata.num ) {
				//sndleft.SetOrigin( ( Vec2Angle( sndleft.intersectionOffset.Length(), sndleft.intersectionAngle + angle ), sndleft.floorz ), true );
				sndleft.SetOrigin( ( Vec2Angle( 8.0, angle + 90.0 ), target.pos.z ), true );
				sndright.SetOrigin( ( Vec2Angle( 8.0, angle - 90.0 ), target.pos.z ), true );

				//sndactor.interpMaxTics = sndactor.interpTic = 15;
			} else {
				vector2 minposxy[ W2SD_Quantity ];
				double minlength[ W2SD_Quantity ];

				minlength[ W2SD_Left ] = 9999.9; // Actually must be greater than an environment test radius.
				minlength[ W2SD_Right ] = 9999.9;

				vector2 plp = pos.xy;

				for ( int j = 0; j < groupdata.lines.Size(); j++ ) {
					Line curline = groupdata.lines[ j ];
					double curminlength = 1e304;
					vector2 curposxy;

					vector2 v1p = curline.v1.p;
					vector2 v2p = curline.v2.p;

					if ( ( (v1p - plp) dot (v1p - v2p) <= 0.0 ) || ( (v2p - plp) dot (v2p - v1p) <= 0.0 ) ) {
						double length1 = ( plp - v1p ).Length();
						double length2 = ( plp - v2p ).Length();

						if ( length1 < length2 ) {
							curminlength = length1;
							curposxy = v1p;
						} else {
							curminlength = length2;
							curposxy = v2p;
						}

					} else {
						double dlx = curline.delta.x;
						double dly = curline.delta.y;

						if ( dlx == 0 ) {
							curposxy = (v1p.x, pos.y);

						} else if ( dly == 0 ) {
							curposxy = (pos.x, v1p.y);

						} else {
							curposxy.y = (dlx * (v1p.y * (dlx/dly) - v1p.x + pos.x) + dly*pos.y)/((dlx * dlx/dly) + dly);
							curposxy.x = (curposxy.y - v1p.y) * (dlx / dly) + v1p.x;
						}

						curminlength = ( curposxy - plp ).Length();
					}

					// Belonging of the sound origin (to left/to right from current player):
					if ( curminlength < minlength[ W2SD_Left ] || curminlength < minlength[ W2SD_Right ] ) {
						vector2 vec2plleft = AngleToVector( target.angle - 90.0, 1.0 );

						double v1leftProjection = ( ( plp - v1p ) dot vec2plleft );
						double v2leftProjection = ( ( plp - v2p ) dot vec2plleft );

						//if ( loopdataindices[ i ] == 10 ) console.printf( loopdataindices[ i ] .. "v1leftProjection " .. v1leftProjection .. ", v2leftProjection " .. v2leftProjection );

						if ( ( v1leftProjection >= 0.0 || v2leftProjection >= 0.0 ) && ( curminlength < minlength[ W2SD_Left ] ) ) {
							minlength[ W2SD_Left ] = curminlength;
							minposxy[ W2SD_Left ] = curposxy;
						}

						if ( ( v1leftProjection <= 0.0 || v2leftProjection <= 0.0 ) && ( curminlength < minlength[ W2SD_Right ] ) ) {
							minlength[ W2SD_Right ] = curminlength;
							minposxy[ W2SD_Right ] = curposxy;
						}
					} // of if ( curminlength < minlength[ W2SD_Left ] || curminlength < minlength[ W2SD_Right ] ) {}

				} // of for ( int j = 0; j < groupdata.lines.Size(); j++ ) {}

				/*double minlengthOpposite[ W2SD_Quantity ];

				for ( int dir = 0; dir < W2SD_Quantity; dir++ ) {
					EWeathremumSoundDirection oppositeDir = dir ^ ( W2SD_Left ^ W2SD_Right );

					minlengthOpposite[ oppositeDir ] = min( 768.0, oppositeSoundDistMul( target.angle ) * minlength[ dir ] );
				}

				minlength[ W2SD_Left ] = min( minlength[ W2SD_Left ], minlengthOpposite[ W2SD_Left ] );
				minlength[ W2SD_Right ] = min( minlength[ W2SD_Right ], minlengthOpposite[ W2SD_RIght ] );*/

				//console.printf( "%4i grp %2i. %s", level.maptime, loopdataindices[ i ], leftdebug );
				//console.printf( "%4i grp %2i. %s", level.maptime, loopdataindices[ i ], rightdebug );

				/*if ( minlength[ W2SD_Right ] < minlength[ W2SD_Left ] ) {
					Actor marker = Actor.Spawn( "tempLeftRightMarker", ( minposxy[ W2SD_Right ], target.pos.z + 22.0 ) );
					marker.scale = ( 0.5, 0.5 );
					marker.angle = 0.0;
				} else if ( minlength[ W2SD_Right ] == minlength[ W2SD_Left ] ) {
					Actor marker = Actor.Spawn( "tempLeftRightMarker", ( minposxy[ W2SD_Left ], target.pos.z + 22.0 ) );
					marker.scale = ( 0.25, 1.0 );
					marker.angle = 90.0 + ( ( level.maptime & 1 ) * 180.0 );
				} else {
					Actor marker = Actor.Spawn( "tempLeftRightMarker", ( minposxy[ W2SD_Left ], target.pos.z + 22.0 ) );
					marker.scale = ( -0.5, 0.5 );
					marker.angle = 180.0;
				}*/

				if ( minlength[ W2SD_Right ] > 9000.0 )
					minposxy[ W2SD_Right ] = minposxy[ W2SD_Left ];
				else if ( minlength[ W2SD_Left ] > 9000.0 )
					minposxy[ W2SD_Left ] = minposxy[ W2SD_Right ];

				double langlediff = ( atan2( minposxy[ W2SD_Left ].y - target.pos.y, minposxy[ W2SD_Left ].x - target.pos.x ) - target.angle ) % 360.0;
				double ranglediff = ( atan2( minposxy[ W2SD_Right ].y - target.pos.y, minposxy[ W2SD_Right ].x - target.pos.x ) - target.angle ) % 360.0;

				double leftmul = oppositeSoundDistMul( langlediff - 90.0 );
				double rightmul = oppositeSoundDistMul( ranglediff + 90.0 );

				// TODO: Find and use a weighted formula.
				double leftlen = min( 768.0, minlength[ W2SD_Left ], minlength[ W2SD_Right ] * leftmul );
				double rightlen = min( 768.0, minlength[ W2SD_Right ], minlength[ W2SD_Left ] * rightmul );

				//console.printf( TEXTCOLOR_DARKGREEN .. "%4i grp %2i. SetLeft " .. leftlen .. " (mult %2.2f), SetRight " .. rightlen .. " (mult %2.2f).", level.maptime, loopdataindices[ i ], leftmul, rightmul );

				// TODO: "pos.z" coordinate based on the closest (?) sector in current group.
				sndleft.SetOrigin( ( Vec2Angle( leftlen, angle + 90.0 ), target.pos.z ), true );
				sndright.SetOrigin( ( Vec2Angle( rightlen, angle - 90.0 ), target.pos.z ), true );

				//sndleft.LinedefMove( minposxy[ W2SD_Left ] );
				//sndright.LinedefMove( minposxy[ W2SD_Right ] );

				//sndactor.intersectionOffset = ( sndactor.pos.xy - pos.xy );
				//sndactor.intersectionAngle = atan2( sndactor.intersectionOffset.y, sndactor.intersectionOffset.x ) - angle;
			}

			sndleft.justCreated = false;
			sndright.justCreated = false;

		} // of for ( int i = 0; i < loopdataindices.Size(); i++ ) {}

	} // of void DoSectorEffects( void ) {}

	double oppositeSoundDistMul( double ang ) {
		return max( 1.0, 4.0 - abs( ( ang % 360.0 ) / 360.0 - 0.5 ) * 12.0 );

		//return ( abs( ( ang % 360.0 ) / 360.0 - 0.5 ) * 5.0 + 1.0 );
		//return ( abs( 1.0 / sin( angle ) + 2.0 ) ) / 3.0;
	}


	void DoRainEffects( void ) {
		// For the cumulative distribution function "sqrt()" addition 
		//thanks to https://habr.com/ru/post/583838/.

		// Outdoor areas raindrop effect:
		for ( int i = 0; i < 200; i++ ) {
			double angletheta = FRandom( 0.0, 360.0 );

			vector2 raindropPos = pos.xy + ( cos( angletheta ), sin( angletheta ) ) * ( 8.0 + sqrt( FRandom( 0.0, 1.0 ) ) * 764.0 );

			Weathremum_Raindrop raindrop = Weathremum_Raindrop( Actor.Spawn( "Weathremum_Raindrop", ( raindropPos, pos.z ) ) );
			raindrop.target = target;
			raindrop.master = self;
			raindrop.w2sector = w2level.allSectorsData[ raindrop.cursector.Index() ];

			//raindrop.vel.xy = ( 10.0, 10.0 ) * ( sin( rainwaveOffset ) + 1.0 );
		}

		// Cornice raindrops effect:
		for ( int i = 0; i < corniceLines.Size(); i++ ) {
			Line l = corniceLines[ i ];
			double linelength = l.delta.Length();

			double minspawnheight = ( l.frontsector? l.frontsector.ceilingplane.d : 1e300 );

			if ( l.backsector && ( l.backsector.ceilingplane.d < minspawnheight ) )
				minspawnheight = l.backsector.ceilingplane.d;

			double spawnCoef = linelength / 96.0;

			int spawnAmount = int( floor( spawnCoef ) );
			double extraSpawnChange = spawnCoef - spawnAmount;

			if ( extraSpawnChange > 0.0 && FRandom( 0.0, 1.0 ) < extraSpawnChange )
				spawnAmount++;

			for ( int i = 0; i < spawnAmount; i++ ) {
				Actor raindrop = Actor.Spawn( "Weathremum_CanopyRaindrop", ( l.v1.p + l.delta / linelength * FRandom( 0.0, linelength ), minspawnheight ) );
				raindrop.master = target;
			}
		}
	} // of void DoRainEffects( void ) {}


	override void Tick() {
		PlayerInfo pl = players[ FriendPlayer ];

		if ( bDORMANT || !playeringame[ FriendPlayer ] || !pl.mo || globalfreeze || level.frozen )
			return;

		target = pl.mo;

		vector3 newpos;

		if ( !multiplayer )
			newpos = ( pl.Camera? pl.Camera.pos : target.pos );
		else
			newpos = ( useMultiplayerPos? multiplayerPos : target.pos );

		//console.printf( "W2PlH <" .. self .. "> target: <" .. target .. "> (Frnd <" .. pl.mo .. ">), useMultipl " .. useMultiplayerPos .. "-> " .. newpos );

		// Move the handler actor to the camera position:
		SetOrigin( newpos, true );
		angle = target.angle; // Singleplayer-aware!!


		// Sector sounds (rain, winds):
		DoSectorEffects();

		// Rain itself, raindrops from cornices:
		DoRainEffects();

		Super.Tick();
	}

} // of class W2PlayerHandler: Actor {}

