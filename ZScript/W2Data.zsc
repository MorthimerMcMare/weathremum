// Weathremum general data classes & constants.

// AA: 0x7FAA0004.
// ZC: 0x7FAA0005 + 0x7FAA0006.
const WeathremumHandlerOrder = 0x7FAA0007;
const STAT_WEATHREMUM_MAINDECOR = Thinker.STAT_USER + 5;
const STAT_WEATHREMUM_EXTRADECOR = STAT_WEATHREMUM_MAINDECOR + 1;


enum EWeathremumHandleStatus {
	W2HS_Off = 0,		// Stopped, inactive sector sound.
	W2HS_Active,		// Active sector sound.
	W2HS_StopSuggestion	// Pre-stop (must be changed to something else every "WorldTick()").
}

enum EWeathremumSectorType {
	W2ST_None = -1,

	W2ST_NextToOutdoor,	// Sill/wind.

	W2ST_NormalSurface,
	W2ST_SoftSurface,	// Grass, carpets, ...
	W2ST_HardSurface,	// Rocks, metal tiles, ...
	W2ST_Water,			// Non-damaging liquids.
	W2ST_Nukage,		// Damaging nukage and slime.
	W2ST_Incandecent,	// Lava and hot rocks (both harmful and harmless).

	W2ST_User,

	W2ST_Normal = W2ST_None,
	W2ST_Wind = W2ST_NextToOutdoor
}

enum EWeathremumSoundDirection {
	W2SD_Left = 0,
	W2SD_Right,

	W2SD_Quantity
}


class W2LevelGeneralData {
	Array<W2SectorData> allSectorsData;		// All of the sectors.

	// TODO: remove??
	Array<int> corniceLinesFlags;			// For the raindrops effect from a canopy.
}


class W2SectorData {
	Sector s;
	Array<Line> lines;
	//Array<int> lineindices; // Temporary, for the UI-scoped "RenderOverlay()".

	EWeathremumSectorType w2type;

	static W2SectorData Create( Sector initSector ) {
		W2SectorData newdata = new( 'W2SectorData' );
		newdata.s = initSector;
		newdata.w2type = W2ST_None;

		return newdata;
	}
}

class W2SoundKeeper play {
	EWeathremumHandleStatus status;

	Sound snd;
	W2SoundOrigin sndorigin[ W2SD_Quantity ];

	Actor master;
	double minlength;
	vector2 minposxy;
	vector2 plp;

	void SuggestPos( vector2 testpos ) {
		double testlength = ( plp - testpos ).Length();

		if ( testlength < minlength ) {
			minlength = testlength;
			minposxy = testpos;
		}
	}

	void SuggestLine( Line curline ) {
		double curminlength = 1e304;
		vector2 curposxy;

		vector2 v1p = curline.v1.p;
		vector2 v2p = curline.v2.p;

		if ( ( (v1p - plp) dot (v1p - v2p) <= 0.0 ) || ( (v2p - plp) dot (v2p - v1p) <= 0.0 ) ) {
			double length1 = ( plp - v1p ).Length();
			double length2 = ( plp - v2p ).Length();

			if ( length1 < length2 ) {
				curminlength = length1;
				curposxy = v1p;
			} else {
				curminlength = length2;
				curposxy = v2p;
			}

		} else {
			double dlx = curline.delta.x;
			double dly = curline.delta.y;

			if ( dlx == 0 ) {
				curposxy = (v1p.x, plp.y);

			} else if ( dly == 0 ) {
				curposxy = (plp.x, v1p.y);

			} else {
				curposxy.y = (dlx * (v1p.y * (dlx/dly) - v1p.x + plp.x) + dly*plp.y)/((dlx * dlx/dly) + dly);
				curposxy.x = (curposxy.y - v1p.y) * (dlx / dly) + v1p.x;
			}

			curminlength = ( curposxy - plp ).Length();
		}

		if ( curminlength < minlength ) {
			minlength = curminlength;
			minposxy = curposxy;
		}

	} // of void SuggestLine( Line curline ) {}

	static W2SoundKeeper Create( Sound initsnd, Actor initmaster ) {
		W2SoundKeeper newkeeper = new( 'W2SoundKeeper' );
		newkeeper.snd = initsnd;
		newkeeper.master = initmaster;

		for ( int j = 0; j < W2SD_Quantity; j++ ) {
			W2SoundOrigin sndactor = newkeeper.sndorigin[ j ] = W2SoundOrigin( Actor.Spawn( "W2SoundOrigin", ( 0.0, 0.0, 0.0 ) ) );
			//sndactor.master = newkeeper;
			sndactor.target = newkeeper.master; // Player or his camera.
			String xsnd = initsnd;
			sndactor.seq = sndactor.StartSoundSequence( xsnd, SeqNode.ENVIRONMENT );
		} // of for ( int j = 0; j < W2SoundKeeper.W2SD_Quantity; j++ ) {}

		return newkeeper;
	} // of static W2SoundKeeper Create( SoundLabel initsnd ) {}


	void PreTick( void ) {
		minlength = 1e304;
		plp = master.pos.xy;

		// Suggest potential excess sounds to stop:
		//status = W2HS_StopSuggestion;
	}

	protected virtual double GetOppositeSoundDistMul( double ang ) {
		double x = ( ang % 360.0 ) / 360.0;

		if ( x < 0.25 )
			return -0.2 * x + 1.0;
		else if ( x < 0.5 )
			return 1.8 * x + 0.5;
		else if ( x < 0.75 )
			return 4.4 * x - 0.8;

		return -6.0 * x + 7.0;

		//return ( abs( ( ang % 360.0 ) / 360.0 - 0.5 ) * 5.0 + 1.0 );
	}

	void PostTick( void ) {
		if ( status == W2HS_StopSuggestion ) {
			// Wiping out too far sounds:
			status = W2HS_Off;

			//console.printf( TEXTCOLOR_DARKRED .. "-Stopped\c- sound for sector " .. loopdataindices[ i ] .. "." );

			//for ( int i = 0; i < W2SD_Quantity; i++ ) {
			//	sndorigin[ i ].Destroy();
		} else {
			//if ( status == W2HS_Active ) {
			//}

			double anglediff = ( atan2( minposxy.y - plp.y, minposxy.x - plp.y ) - master.angle ) % 360.0;

			// TODO: separate left/right lengths!!!
			double leftlen = min( 9999.9, minlength * GetOppositeSoundDistMul( anglediff ) );
			double rightlen = min( 9999.9, minlength * GetOppositeSoundDistMul( anglediff + 180.0 ) );

			//console.printf( TEXTCOLOR_DARKGREEN .. "%4i grp %2i. SetLeft " .. leftlen .. " (mult %2.2f), SetRight " .. rightlen .. " (mult %2.2f).", level.maptime, loopdataindices[ i ], leftmul, rightmul );

			// TODO: "pos.z" coordinate based on the closest (?) sector in current group.
			sndorigin[ W2SD_Left ].SetOrigin( ( master.Vec2Angle( leftlen, master.angle + 90.0 ), master.pos.z ), true );
			sndorigin[ W2SD_Right ].SetOrigin( ( master.Vec2Angle( rightlen, master.angle - 90.0 ), master.pos.z ), true );
		}

	} // of void PostTick( void ) {}

} // of class W2SoundKeeper {}
